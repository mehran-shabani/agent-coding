"""Contradiction detection and reporting for the Local Coding Agent."""

from datetime import datetime
from pathlib import Path
from typing import List, Optional

from rich.console import Console

console = Console()


class ContradictionReport:
    """A contradiction report."""
    
    def __init__(self, title: str, description: str, context: str = ""):
        self.title = title
        self.description = description
        self.context = context
        self.timestamp = datetime.now()
        self.report_id = self.timestamp.strftime("%Y%m%d_%H%M%S")
    
    def to_markdown(self) -> str:
        """Convert to markdown format."""
        content = f"""# Contradiction Report: {self.title}

**Report ID:** {self.report_id}  
**Timestamp:** {self.timestamp.isoformat()}

## Description

{self.description}

## Context

{self.context if self.context else "No additional context provided."}

## Resolution Required

This contradiction must be resolved before the agent can continue automatic execution.

---
*Generated by Local Coding Agent*
"""
        return content
    
    def save_to_file(self, reports_dir: Path) -> Path:
        """Save report to file."""
        reports_dir.mkdir(parents=True, exist_ok=True)
        
        filename = f"contradictions-{self.report_id}.md"
        report_file = reports_dir / filename
        
        try:
            report_file.write_text(self.to_markdown(), encoding='utf-8')
            console.print(f"[red]Contradiction report saved:[/red] {report_file}")
            return report_file
        except Exception as e:
            console.print(f"[red]Error saving contradiction report:[/red] {e}")
            raise


def detect_contradictions(instructions: List[str], requirements: List[str]) -> List[str]:
    """Detect contradictions between instructions and requirements."""
    contradictions = []
    
    # Simple contradiction detection patterns
    contradiction_patterns = [
        # File operations
        ("create", "don't create", "file creation"),
        ("delete", "don't delete", "file deletion"),
        ("overwrite", "don't overwrite", "file overwriting"),
        
        # Safety
        ("safe", "unsafe", "safety requirements"),
        ("confirm", "no confirmation", "user confirmation"),
        
        # LLM usage
        ("use llm", "don't use llm", "LLM usage"),
        ("local only", "remote", "execution location"),
        
        # Output format
        ("markdown", "json", "output format"),
        ("verbose", "quiet", "output verbosity"),
    ]
    
    all_text = " ".join(instructions + requirements).lower()
    
    for positive, negative, category in contradiction_patterns:
        if positive in all_text and negative in all_text:
            contradictions.append(f"Contradiction in {category}: Found both '{positive}' and '{negative}' requirements")
    
    return contradictions


def check_for_contradictions(command: str, args: dict, config_data: dict) -> Optional[ContradictionReport]:
    """Check for contradictions in command execution."""
    
    # Check for specific contradiction scenarios
    
    # Example: Writing to a protected file without permission
    if command == "write":
        file_path = args.get("path", "")
        if file_path.startswith("/etc/") or file_path.startswith("/usr/"):
            return ContradictionReport(
                title="Unsafe File Write",
                description=f"Attempting to write to system directory: {file_path}",
                context=f"Command: {command}, Path: {file_path}"
            )
    
    # Example: Deleting critical files
    if command == "delete":
        file_path = args.get("path", "")
        critical_files = [".env", "pyproject.toml", "README.md"]
        if any(critical in file_path for critical in critical_files):
            return ContradictionReport(
                title="Critical File Deletion",
                description=f"Attempting to delete critical file: {file_path}",
                context=f"Command: {command}, Path: {file_path}"
            )
    
    # Example: Running dangerous commands
    if command == "run":
        shell_command = args.get("command", "")
        dangerous_commands = ["rm -rf /", "format", "shutdown", "reboot"]
        if any(dangerous in shell_command.lower() for dangerous in dangerous_commands):
            return ContradictionReport(
                title="Dangerous Shell Command",
                description=f"Attempting to run dangerous command: {shell_command}",
                context=f"Command: {command}, Shell command: {shell_command}"
            )
    
    return None


def report_contradiction_and_stop(report: ContradictionReport, reports_dir: Path) -> None:
    """Report contradiction and stop execution."""
    
    console.print(f"\n[red bold]CONTRADICTION DETECTED: {report.title}[/red bold]")
    console.print(f"[red]{report.description}[/red]")
    console.print(f"[yellow]Context: {report.context}[/yellow]")
    
    # Save report
    report_file = report.save_to_file(reports_dir)
    
    console.print(f"\n[red]Automatic execution stopped due to contradiction.[/red]")
    console.print(f"[yellow]Please review the report and resolve the contradiction before continuing.[/yellow]")
    console.print(f"[blue]Report saved to: {report_file}[/blue]")
    
    # Stop execution
    import sys
    sys.exit(1)